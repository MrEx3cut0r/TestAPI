# Crypto Price Tracker API

Микросервис для отслеживания цен криптовалют с биржи Deribit. Приложение автоматически собирает цены BTC/USD и ETH/USD каждую минуту, сохраняет их в базу данных и предоставляет REST API для доступа к данным.

## Функциональность

### Сбор данных
- Автоматический забор цен BTC/USD и ETH/USD каждую минуту с API Deribit
- Использование индексных цен (index price)
- Сохранение данных в PostgreSQL: тикер, цена, UNIX timestamp

### API Endpoints (FastAPI)
- `GET /api/v1/prices/?ticker={ticker}` - Получение всех цен по указанному тикеру
- `GET /api/v1/prices/last?ticker={ticker}` - Получение последней цены по тикеру
- `GET /api/v1/prices/by-date?ticker={ticker}&start_date={date}&end_date={date}` - Получение цен с фильтром по дате
- Все методы требуют обязательный query-параметр `ticker`

### Технологический стек
- **Backend**: FastAPI (Python 3.11+)
- **База данных**: PostgreSQL
- **Очереди задач**: Celery + Redis
- **HTTP клиент**: Aiohttp
- **Контейнеризация**: Docker + Docker Compose
- **ORM**: SQLAlchemy 2.0
- **Валидация**: Pydantic 2.0

## Быстрый старт
```
git clone https://github.com/MrEx3cut0r/TestAPI
cd TestAPI
sudo docker compose build # билдим
sudo docker compose up # запускаем
```

## Тестирование
Для запуска тестов требуется pytest 7.4.0
```
cd tests
pytest # запускаем тесты
```

### Требования
- Docker 20.10+
- Docker Compose 2.0+

## Архитектурные решения

**Clean Architecture**
Проект построен по принципам чистой архитектуры с четким разделением на слои:

- **Domain Layer** - ядро приложения, содержит бизнес-сущности и логику
- **Application Layer** - сценарии использования (use cases) и бизнес-правила
- **Infrastructure Layer** - реализации внешних зависимостей (БД, API клиенты)
- **Presentation Layer** - API контроллеры и схемы валидации

**Инверсия зависимостей**
Все зависимости направлены внутрь системы. Внешние слои зависят от внутренних через абстракции (порты/интерфейсы).

### Технические решения

**Асинхронность**
- FastAPI с async/await для обработки HTTP запросов
- Aiohttp для асинхронных запросов к Deribit API
- SQLAlchemy 2.0 с asyncpg для асинхронной работы с PostgreSQL

**Работа с внешним API**
- DeribitClient инкапсулирует всю логику взаимодействия с биржей
- Поддержка ретраев и обработки ошибок на уровне HTTP клиента
- Использование индексных цен как наиболее стабильного источника данных

**Фоновые задачи**
- Celery для периодического сбора данных каждую минуту
- Redis как брокер сообщений и бэкенд для результатов
- Изоляция event loop'ов для предотвращения конфликтов в асинхронных задачах

**База данных**
- PostgreSQL как реляционная СУБД для хранения исторических данных
- Составные индексы (ticker + timestamp) для оптимизации частых запросов
- Использование UNIX timestamp для единообразия временных меток

### API Дизайн

**RESTful подход**
- Все endpoints используют HTTP GET методы
- Обязательный параметр `ticker` для фильтрации данных
- Стандартные коды ответов HTTP (200, 400, 404, 500)

**Валидация**
- Pydantic 2.0 для валидации входных данных и сериализации ответов
- Автоматическая генерация OpenAPI документации
- Кастомные валидаторы для тикеров и временных меток

### Контейнеризация

**Мульти-сервисная архитектура**
- Разделение на app, celery-worker, celery-beat, postgres, redis
- Каждый сервис в отдельном контейнере для изоляции
- Docker Compose для оркестрации всех компонентов

**Переменные окружения**
- Централизованная конфигурация через .env файл
- Разделение настроек для development/production
- Безопасное хранение чувствительных данных

### Тестирование

**Пирамида тестирования**
- Unit тесты для доменной логики и use cases
- Интеграционные тесты для API endpoints
- Изоляция тестовых данных от production

### Мониторинг и логирование

**Структурированные логи**
- Разные уровни логирования для разных компонентов
- Логирование в консоль и файлы с ротацией
- Информативные сообщения об ошибках

**Health checks**
- Эндпоинт /health для мониторинга состояния приложения
- Проверка подключения к зависимостям (БД, Redis)
- Автоматический перезапуск при сбоях

### Безопасность

**Валидация входных данных**
- Проверка всех параметров запроса
- Защита от SQL injection через ORM
- Ограничение типов поддерживаемых тикеров

**Производительность**
- Connection pooling для БД и Redis
- Кэширование частых запросов
- Оптимизированные индексы в базе данных